---
layout: post
title: "[SW Expert Academy] 1859번 백만 장자 프로젝트"
date: 2019-08-08
excerpt: "SW expert Acadmy 1859번 풀어보기"
tag:
- SW Expert Academy
- D2
comments: false
---
수정중인 코드입니다.

```c++
#include <iostream>

using namespace std;

struct uphill {			//매매가가 오르막길 형태를 띌 때 시작지점(start)과 끝지점(peak)를 기억한다.
	int start;
	int peak;
};

template <typename T>
class queue {			//크기가 2배씩 증가하는 동적큐
private:
	int rear;
	int front;
	int capacity;
	T* array;
public:
	queue();
	T dequeue();
	void enqueue(T newdata);
	void resize();
	~queue();
	bool isFull();
	bool isEmpty();
};

template <typename T>
queue<T>::queue() {
	capacity = 1;
	array = new T[capacity];
	front = rear = -1;
}

template <typename T>
bool queue<T>::isFull() {
	return ((rear + 1) % capacity == front);
}

template <typename T>
bool queue<T>::isEmpty() {
	return (front == -1);
}

template <typename T>
T queue<T>::dequeue() {
	T data = NULL;
	if (isEmpty())
		return data;
	else {
		data = array[front];
		if (front == rear)
			front = rear = -1;
		else
			front = (front + 1) % capacity;
	}
	return data;
}

template <typename T>
void queue<T>::enqueue(T newdata) {
	if (isFull())
		resize();
	rear = (rear + 1) % capacity;
	array[rear] = newdata;
	if (front == -1)
		front = rear;
}

template <typename T>
void queue<T>::resize() {
	int oldCapacity = capacity;
	T* oldArray = array;
	capacity *= 2;
	array = new T[capacity];
	
	for (int i = 0; i < oldCapacity; i++)
		array[i] = oldArray[i];

	delete oldArray;
}

template <typename T>
queue<T>::~queue() {
	delete array;
}


class predictMax {
private:
	int testCase;
	unsigned long getMax(short *price, int N);
public:
	predictMax(int T) { testCase = T; };
	void solve();
};

unsigned long predictMax::getMax(short *price, int N) {
	unsigned long result = 0;
	queue<uphill> uphills;
	uphill newdata;

	for (int i = 0; i < N; i++) {
		cin >> price[i];
		if (i == 0)
			continue;

		if (price[i - 1] < price[i]) {
			if (i == 1) {
				
				newdata.start = i - 1;
			}
			else if (price[i - 2] > price[i - 1]) {
				newdata.start = i - 1;
			}
		}
		/*내용추가*/
	}
	return result;
}

void predictMax::solve() {
	int N;
	for (int i = 0; i < testCase; i++) {
		short * price;
		cin >> N;
		price = new short[N];

		cout << "#" << i + 1 << getMax(price, N) << endl;

		delete price;
	}
}

int main() {
	int T;
	cin >> T;

	predictMax pm(T);
	pm.solve();

	return 0;
}
```
## 아이디어
- 오르기 시작하는 지점 기억
- 내리기 시작하는 지점의 직전(peak) 기억

-> 피크들 중 제일 큰 값을 뽑음. 첫번째 오르기 시작하는 지점부터 제일 큰 피크값까지의 차이값을 모두 더함.
->이전 max피크 이후 인덱스에 있는 피크들 중 제일 큰 값을 뽑음. 이전 max피크 이후 인덱스의 오르기 시작하는 지점부터 해당 피크값까지의 차이값을 모두 더함
->반복

* 업데이트(2019-08-09): uphill(매매가가 상승하는 구간)을 저장하기 위한 queue 구현. linear search로 maxPeak를 찾는 연산 필요
